/*
 * 커스텀 파이프라인 예제 파일
 * 
 * 이 파일을 참고하여 자신만의 파이프라인을 만들 수 있습니다.
 * 사용하려면 파일명에서 .example 확장자를 제거하고,
 * YourCustomAssetType을 실제 타입으로 변경하세요.
 */

#if UNITY_EDITOR
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

namespace NAKZI.AvatarPreset.Pipeline.Pipelines
{
    // 이 예제에서는 주석 처리된 상태로 두었습니다.
    // 실제 사용 시 주석을 해제하고 타입을 변경하세요.
    
    // [AssetClonePipelineFor(typeof(YourCustomAssetType))]
    public class ExampleCustomPipeline : IAssetClonePipeline
    {
        /// <summary>
        /// 우선순위. 낮을수록 먼저 실행됩니다.
        /// 같은 타입에 대해 여러 파이프라인이 등록된 경우,
        /// 가장 낮은 우선순위를 가진 파이프라인이 사용됩니다.
        /// </summary>
        public int Priority => 0;

        /// <summary>
        /// 복제된 에셋의 내부 참조를 재연결합니다.
        /// </summary>
        /// <param name="asset">재연결할 복제된 에셋</param>
        /// <param name="clonedMap">원본 경로 -> 복제된 에셋 매핑</param>
        /// <returns>재연결이 수행되었으면 true</returns>
        public bool OnRemap(Object asset, Dictionary<string, Object> clonedMap)
        {
            // 1. 타입 체크
            // if (asset is not YourCustomAssetType customAsset) return false;

            bool modified = false;

            // 2. 에셋의 참조 필드를 순회하며 재연결
            // 예: customAsset.myReference가 복제된 에셋을 가리키도록 변경
            
            /*
            if (customAsset.myReference != null)
            {
                string refPath = AssetDatabase.GetAssetPath(customAsset.myReference);
                if (!string.IsNullOrEmpty(refPath) && clonedMap.TryGetValue(refPath, out Object cloned))
                {
                    customAsset.myReference = cloned as MyReferenceType;
                    modified = true;
                }
            }
            */

            // 3. SerializedObject를 사용한 방법 (모든 ObjectReference 필드 순회)
            /*
            SerializedObject so = new SerializedObject(asset);
            SerializedProperty iterator = so.GetIterator();
            bool enterChildren = true;

            while (iterator.NextVisible(enterChildren))
            {
                enterChildren = false;

                if (iterator.propertyType != SerializedPropertyType.ObjectReference) continue;

                Object originalRef = iterator.objectReferenceValue;
                if (!originalRef) continue;

                string originalPath = AssetDatabase.GetAssetPath(originalRef);
                if (string.IsNullOrEmpty(originalPath)) continue;

                if (clonedMap.TryGetValue(originalPath, out Object cloned))
                {
                    iterator.objectReferenceValue = cloned;
                    modified = true;
                }
            }

            if (modified)
            {
                so.ApplyModifiedPropertiesWithoutUndo();
            }
            */

            // 4. 변경 사항 저장
            if (modified)
            {
                EditorUtility.SetDirty(asset);
                AssetDatabase.SaveAssetIfDirty(asset);
            }

            return modified;
        }

        /// <summary>
        /// 에셋 복제 전에 호출됩니다. (선택적 구현)
        /// </summary>
        public void OnBeforeClone(Object originalAsset, string targetPath)
        {
            // 복제 전 전처리가 필요한 경우 구현
            // 예: 특정 설정 백업, 검증 등
        }

        /// <summary>
        /// 에셋 복제 후에 호출됩니다. (선택적 구현)
        /// </summary>
        public void OnAfterClone(Object originalAsset, Object clonedAsset)
        {
            // 복제 후 후처리가 필요한 경우 구현
            // 예: 복제된 에셋의 특정 필드 초기화, 이름 변경 등
        }
    }
}
#endif

